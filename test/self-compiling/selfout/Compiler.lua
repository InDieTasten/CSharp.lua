-- Generated by CSharp.lua Compiler 1.1.0
--[[
Copyright 2017 YANG Huan (sy.yanghuan@gmail.com).

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
]]
local System = System
local Linq = System.Linq.Enumerable
local MicrosoftCodeAnalysis = Microsoft.CodeAnalysis
local MicrosoftCodeAnalysisCSharp = Microsoft.CodeAnalysis.CSharp
local SystemIO = System.IO
local SystemReflection = System.Reflection
local SystemThreading = System.Threading
local CSharpLua
local CSharpLuaLuaSyntaxGenerator
System.usingDeclare(function (global) 
  CSharpLua = global.CSharpLua
  CSharpLuaLuaSyntaxGenerator = CSharpLua.LuaSyntaxGenerator
end)
System.namespace("CSharpLua", function (namespace) 
  namespace.class("Compiler", function (namespace) 
    local SystemDlls, GetMetas, IsCorrectSystemDll, GetLibraries, Do, Compile, __staticCtor__, __ctor__
    __staticCtor__ = function (this) 
      SystemDlls = System.Array(System.String)("System.dll", "System.Core.dll", "System.Runtime.dll", "System.Linq.dll", "Microsoft.CSharp.dll")
    end
    __ctor__ = function (this, inputDirectory, outputDirectory, libraries, metas, cscArguments, isClassic, indentCount, attributes) 
      this._inputDirectory = inputDirectory
      this._outputDirectory = outputDirectory
      this._libraries = CSharpLua.Utility.Split(libraries, true)
      this._metas = CSharpLua.Utility.Split(metas, true)
      local default
      if System.String.IsNullOrEmpty(cscArguments) then
        default = System.Array.Empty(System.String)
      else
        default = cscArguments:Trim():Split(59 --[[';']], 44 --[[',']], 32 --[[' ']])
      end
      this._cscArguments = default
      this._isNewest = not isClassic
      this._useSemicolons = false
      local extern
      extern, this._indentCount = System.Int.TryParse(indentCount, nil)
      if attributes ~= nil then
        this._attributes = CSharpLua.Utility.Split(attributes, false)
      end
    end
    GetMetas = function (this) 
      local metas = System.create(System.List(System.String)(), function (default) 
        default:Add(CSharpLua.Utility.GetCurrentDirectory("~/System.xml" --[[Compiler._systemMetadata]]))
      end)
      metas:AddRange(this._metas)
      return metas
    end
    IsCorrectSystemDll = function (this, path) 
      local default, extern = System.try(function () 
        SystemReflection.Assembly.LoadFile(path)
        return true, true
      end, function (default) 
        return true, false
      end)
      if default then
        return extern
      end
    end
    GetLibraries = function (this) 
      local privateCorePath = System.typeof(System.Object):getAssembly():getLocation()
      local libraries = System.create(System.List(System.String)(), function (default) 
        default:Add(privateCorePath)
      end)

      local systemDirectory = SystemIO.Path.GetDirectoryName(privateCorePath)
      for _, path in System.each(SystemIO.Directory.EnumerateFiles(systemDirectory, "*.dll")) do
        if IsCorrectSystemDll(this, path) then
          libraries:Add(path)
        end
      end

      for _, library in System.each(this._libraries) do
        local default
        if library:EndsWith(".dll" --[[Compiler._dllFileExtension]]) then
          default = library
        else
          default = library .. ".dll" --[[Compiler._dllFileExtension]]
        end
        local path = default
        if SystemIO.File.Exists(path) then
          libraries:Add(path)
        else
          local file = SystemIO.Path.Combine(systemDirectory, SystemIO.Path.GetFileName(path))
          if not SystemIO.File.Exists(file) then
            System.throw(CSharpLua.CmdArgumentException(("-l {0} couldn't be found."):Format(path)))
          end
        end
      end
      return libraries
    end
    Do = function (this) 
      Compile(this)
    end
    -- <summary>
    -- Compiles .cs files to CS syntax tree, generates Lua syntax tree, and generates .lua files
    -- </summary>
    Compile = function (this) 
      -- Apply configurations
      local commandLineArguments = MicrosoftCodeAnalysisCSharp.CSharpCommandLineParser.getDefault():Parse(this._cscArguments)
      local parseOptions = commandLineArguments:getParseOptions():WithDocumentationMode(1 --[[DocumentationMode.Parse]])
      local files = SystemIO.Directory.EnumerateFiles(this._inputDirectory, "*.cs", 1 --[[SearchOption.AllDirectories]])
      local generatorSettings = System.create(CSharpLuaLuaSyntaxGenerator.SettingInfo(), function (default) 
        default.IsNewest = this._isNewest
        default.HasSemicolon = this._useSemicolons
        default:setIndent(this._indentCount)
      end)

      -- Build CS syntax trees
      local syntaxTrees = Linq.Select(files, function (file) 
        return MicrosoftCodeAnalysisCSharp.CSharpSyntaxTree.ParseText(SystemIO.File.ReadAllText(file), parseOptions, file, nil, System.default(SystemThreading.CancellationToken))
      end, MicrosoftCodeAnalysis.SyntaxTree)
      local references = Linq.Select(GetLibraries(this), function (i) 
        return MicrosoftCodeAnalysis.MetadataReference.CreateFromFile(i, System.default(MicrosoftCodeAnalysis.MetadataReferenceProperties))
      end, MicrosoftCodeAnalysis.PortableExecutableReference)

      -- Generate lua output
      local generator = CSharpLua.LuaSyntaxGenerator(syntaxTrees, references, commandLineArguments:getCompilationOptions(), GetMetas(this), generatorSettings, this._attributes, this._inputDirectory)
      generator:Generate(this._outputDirectory)
    end
    return {
      _isNewest = false, 
      _indentCount = 0, 
      _useSemicolons = false, 
      Do = Do, 
      __staticCtor__ = __staticCtor__, 
      __ctor__ = __ctor__
    }
  end)
end)
