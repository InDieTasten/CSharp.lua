-- Generated by CSharp.lua Compiler 1.1.0
local System = System
local MicrosoftCodeAnalysis
local MicrosoftCodeAnalysisCSharp
System.usingDeclare(function (global) 
  MicrosoftCodeAnalysis = Microsoft.CodeAnalysis
  MicrosoftCodeAnalysisCSharp = Microsoft.CodeAnalysis.CSharp
end)
System.namespace("Microsoft.CodeAnalysis.CSharp", function (namespace) 
  namespace.class("CSharpCommandLineParser", function (namespace) 
    local Default, getRegularFileExtension, getScriptFileExtension, Parse1, CommonParse, GenerateErrorForNoFilesFoundInRecurse, __staticCtor__, __ctor__
    __staticCtor__ = function (this) 
      Default = MicrosoftCodeAnalysisCSharp.CSharpCommandLineParser(false)
      this.Default = Default
    end
    __ctor__ = function (this, isScriptCommandLineParser) 
      this.__base__.__ctor__(this, Microsoft.CodeAnalysis.CSharp.MessageProvider.Instance, isScriptCommandLineParser)
    end
    getRegularFileExtension = function (this) 
      return System.throw(System.NotImplementedException())
    end
    getScriptFileExtension = function (this) 
      return System.throw(System.NotImplementedException())
    end
    Parse1 = function (this, args, baseDirectory, sdkDirectory, additionalReferenceDirectories) 
      local diagnostics = System.List(MicrosoftCodeAnalysis.Diagnostic)()
      local flattenedArgs = System.List(System.String)()

      -- Reduced imput parameters
      this:FlattenArgs(args, nil, flattenedArgs, nil, baseDirectory)

      local appConfigPath = nil
      local displayLogo = true
      local displayHelp = false
      local displayVersion = false
      local displayLangVersions = false
      local optimize = false
      local checkOverflow = false
      local allowUnsafe = false
      local concurrentBuild = true
      local deterministic = false
      -- TODO(5431): Enable deterministic mode by default
      local emitPdb = false
      local debugPlus = false
      local pdbPath = nil
      local noStdLib = this.IsScriptCommandLineParser
      -- don't add mscorlib from sdk dir when running scripts
      local outputDirectory = baseDirectory
      local outputFileName = nil
      local outputRefFilePath = nil
      local refOnly = false
      local documentationPath = nil
      local errorLogPath = nil
      local parseDocumentationComments = false
      --Don't just null check documentationFileName because we want to do this even if the file name is invalid.
      local utf8output = false
      local outputKind = 0 --[[OutputKind.ConsoleApplication]]
      local subsystemVersion = MicrosoftCodeAnalysis.SubsystemVersion.getNone()
      local languageVersion = 0 --[[LanguageVersion.Default]]
      local mainTypeName = nil
      local win32ManifestFile = nil
      local win32ResourceFile = nil
      local win32IconFile = nil
      local noWin32Manifest = false
      local platform = 0 --[[Platform.AnyCpu]]
      local baseAddress = 0
      local fileAlignment = 0
      local delaySignSetting = nil
      local keyFileSetting = nil
      local keyContainerSetting = nil
      local managedResources = System.List(MicrosoftCodeAnalysis.ResourceDescription)()
      local sourceFiles = System.List(MicrosoftCodeAnalysis.CommandLineSourceFile)()
      local additionalFiles = System.List(MicrosoftCodeAnalysis.CommandLineSourceFile)()
      local embeddedFiles = System.List(MicrosoftCodeAnalysis.CommandLineSourceFile)()
      local sourceFilesSpecified = false
      local embedAllSourceFiles = false
      local resourcesOrModulesSpecified = false
      local codepage = nil
      local metadataReferences = System.List(MicrosoftCodeAnalysis.CommandLineReference)()
      local analyzers = System.List(MicrosoftCodeAnalysis.CommandLineAnalyzerReference)()
      local libPaths = System.List(System.String)()
      local sourcePaths = System.List(System.String)()
      local keyFileSearchPaths = System.List(System.String)()
      local usings = System.List(System.String)()
      local generalDiagnosticOption = 0 --[[ReportDiagnostic.Default]]
      local diagnosticOptions = System.Dictionary(System.String, System.Int)()
      local noWarns = System.Dictionary(System.String, System.Int)()
      local warnAsErrors = System.Dictionary(System.String, System.Int)()
      local warningLevel = 4
      local highEntropyVA = false
      local printFullPaths = false
      local moduleAssemblyName = nil
      local moduleName = nil
      local features = System.List(System.String)()
      local runtimeMetadataVersion = nil
      local errorEndLocation = false
      local reportAnalyzer = false
      local touchedFilesPath = nil
      local optionsEnded = false
      local interactiveMode = false
      local publicSign = false
      local sourceLink = nil
      local ruleSetPath = nil

      -- Process ruleset files first so that diagnostic severity settings specified on the command line via
      -- /nowarn and /warnaserror can override diagnostic severity settings specified in the ruleset file.
      if not this.IsScriptCommandLineParser then
        for _, arg in System.each(flattenedArgs) do
          local name, value
          local default
          default, name, value = MicrosoftCodeAnalysis.CommandLineParser.TryParseOption(arg)
          if default and (name == "ruleset") then
            local unquoted = MicrosoftCodeAnalysis.CommandLineParser.RemoveQuotesAndSlashes(value)

            if System.String.IsNullOrEmpty(unquoted) then
              System.throw(System.NotImplementedException())
              -- [Lua] AddDiagnostic(diagnostics, ErrorCode.ERR_SwitchNeedsString, "<text>", name);
            else
              System.throw(System.NotImplementedException())
              -- [Lua] ruleSetPath = ParseGenericPathToFile(unquoted, diagnostics, baseDirectory);
              System.throw(System.NotImplementedException())
              -- [Lua] generalDiagnosticOption = GetDiagnosticOptionsFromRulesetFile(ruleSetPath, out diagnosticOptions, diagnostics);
            end
          end
        end
      end

      for _, arg in System.each(flattenedArgs) do
        local continue
        repeat
          --Debug.Assert(optionsEnded || !arg.StartsWith("@", StringComparison.Ordinal));

          local name, value
          local extern
          extern, name, value = MicrosoftCodeAnalysis.CommandLineParser.TryParseOption(arg)
          if optionsEnded or not extern then
            sourceFiles:AddRange(this:ParseFileArgument(arg, baseDirectory, diagnostics))
            if #sourceFiles > 0 then
              sourceFilesSpecified = true
            end

            continue = true
            break
          end

          repeat
            local ref = name
            if ref == "?" or ref == "help" or ref == "version" or ref == "r" or ref == "reference" or ref == "features" or ref == "lib" or ref == "libpath" or ref == "libpaths" then
              System.throw(System.NotImplementedException())
            end
          until 1

          if this.IsScriptCommandLineParser then
            System.throw(System.NotImplementedException())
            -- [Lua]
          else
            repeat
              local out = name
              if out == "a" or out == "analyzer" or out == "d" or out == "define" or out == "codepage" or out == "checksumalgorithm" or out == "checked" or out == "checked+" or out == "checked-" or out == "instrument" or out == "noconfig" or out == "sqmsessionguid" or out == "preferreduilang" or out == "out" or out == "refout" or out == "refonly" or out == "t" or out == "target" or out == "moduleassemblyname" or out == "modulename" or out == "platform" or out == "recurse" or out == "doc" or out == "addmodule" or out == "l" or out == "link" or out == "win32res" or out == "win32icon" or out == "win32manifest" or out == "nowin32manifest" or out == "res" or out == "resource" or out == "linkres" or out == "linkresource" or out == "sourcelink" or out == "debug" or out == "debug+" or out == "debug-" or out == "o" or out == "optimize" or out == "o+" or out == "optimize+" or out == "o-" or out == "optimize-" or out == "deterministic" or out == "deterministic+" or out == "deterministic-" or out == "p" or out == "parallel" or out == "p+" or out == "parallel+" or out == "p-" or out == "parallel-" or out == "warnaserror" or out == "warnaserror+" or out == "warnaserror-" or out == "w" or out == "warn" or out == "nowarn" or out == "unsafe" or out == "unsafe+" or out == "unsafe-" or out == "langversion" or out == "delaysign" or out == "delaysign+" or out == "delaysign-" or out == "publicsign" or out == "publicsign+" or out == "publicsign-" or out == "keyfile" or out == "keycontainer" or out == "highentropyva" or out == "highentropyva+" or out == "highentropyva-" or out == "nologo" or out == "baseaddress" or out == "subsystemversion" or out == "touchedfiles" or out == "bugreport" or out == "m" or out == "main" or out == "fullpaths" or out == "pathmap" or out == "filealign" or out == "pdb" or out == "errorendlocation" or out == "reportanalyzer" or out == "nostdlib" or out == "nostdlib+" or out == "nostdlib-" or out == "errorreport" or out == "errorlog" or out == "appconfig" or out == "runtimemetadataversion" or out == "ruleset" or out == "additionalfile" or out == "embed" then
                System.throw(System.NotImplementedException())
              end
            until 1
          end

          -- AddDiagnostic(diagnostics, ErrorCode.ERR_BadSwitch, arg);
          continue = true
        until 1
        if not continue then
          break
        end
      end

      System.throw(System.NotImplementedException())
      -- [Lua]
      --            foreach (var o in warnAsErrors)
      --            {
      --                diagnosticOptions[o.Key] = o.Value;
      --            }

      --            // Specific nowarn options always override specific warnaserror options.
      --            foreach (var o in noWarns)
      --            {
      --                diagnosticOptions[o.Key] = o.Value;
      --            }

      --            if (refOnly && outputRefFilePath != null)
      --            {
      --                AddDiagnostic(diagnostics, diagnosticOptions, ErrorCode.ERR_NoRefOutWhenRefOnly);
      --            }

      --            if (outputKind == OutputKind.NetModule && (refOnly || outputRefFilePath != null))
      --            {
      --                AddDiagnostic(diagnostics, diagnosticOptions, ErrorCode.ERR_NoNetModuleOutputWhenRefOutOrRefOnly);
      --            }

      --            if (!IsScriptCommandLineParser && !sourceFilesSpecified && (outputKind.IsNetModule() || !resourcesOrModulesSpecified))
      --            {
      --                AddDiagnostic(diagnostics, diagnosticOptions, ErrorCode.WRN_NoSources);
      --            }

      --            if (!noStdLib && sdkDirectory != null)
      --            {
      --                metadataReferences.Insert(0, new CommandLineReference(Path.Combine(sdkDirectory, "mscorlib.dll"), MetadataReferenceProperties.Assembly));
      --            }

      --            if (!platform.Requires64Bit())
      --            {
      --                if (baseAddress > uint.MaxValue - 0x8000)
      --                {
      --                    AddDiagnostic(diagnostics, ErrorCode.ERR_BadBaseNumber, string.Format("0x{0:X}", baseAddress));
      --                    baseAddress = 0;
      --                }
      --            }

      --            // add additional reference paths if specified
      --            if (!string.IsNullOrWhiteSpace(additionalReferenceDirectories))
      --            {
      --                ParseAndResolveReferencePaths(null, additionalReferenceDirectories, baseDirectory, libPaths, MessageID.IDS_LIB_ENV, diagnostics);
      --            }

      --            ImmutableArray<string> referencePaths = BuildSearchPaths(sdkDirectory, libPaths, responsePaths);

      --            ValidateWin32Settings(win32ResourceFile, win32IconFile, win32ManifestFile, outputKind, diagnostics);

      --            // Dev11 searches for the key file in the current directory and assembly output directory.
      --            // We always look to base directory and then examine the search paths.
      --            keyFileSearchPaths.Add(baseDirectory);
      --            if (baseDirectory != outputDirectory)
      --            {
      --                keyFileSearchPaths.Add(outputDirectory);
      --            }

      --            // Public sign doesn't use the legacy search path settings
      --            if (publicSign && !string.IsNullOrWhiteSpace(keyFileSetting))
      --            {
      --                keyFileSetting = ParseGenericPathToFile(keyFileSetting, diagnostics, baseDirectory);
      --            }

      --            if (sourceLink != null && !emitPdb)
      --            {
      --                AddDiagnostic(diagnostics, ErrorCode.ERR_SourceLinkRequiresPdb);
      --            }

      --            if (embedAllSourceFiles)
      --            {
      --                embeddedFiles.AddRange(sourceFiles);
      --            }

      --            if (embeddedFiles.Count > 0 && !emitPdb)
      --            {
      --                AddDiagnostic(diagnostics, ErrorCode.ERR_CannotEmbedWithoutPdb);
      --            }

      --            var parsedFeatures = ParseFeatures(features);

      --            string compilationName;
      --            GetCompilationAndModuleNames(diagnostics, outputKind, sourceFiles, sourceFilesSpecified, moduleAssemblyName, ref outputFileName, ref moduleName, out compilationName);

      --var parseOptions = new CSharpParseOptions
      --(
      --    languageVersion: languageVersion,
      --    preprocessorSymbols: defines.ToImmutableAndFree(),
      --    documentationMode: parseDocumentationComments ? DocumentationMode.Diagnose : DocumentationMode.None,
      --    kind: IsScriptCommandLineParser ? SourceCodeKind.Script : SourceCodeKind.Regular,
      --    features: parsedFeatures
      --);

      --            // We want to report diagnostics with source suppression in the error log file.
      --            // However, these diagnostics won't be reported on the command line.
      --            var reportSuppressedDiagnostics = errorLogPath != null;

      --            var options = new CSharpCompilationOptions
      --            (
      --                outputKind: outputKind,
      --                moduleName: moduleName,
      --                mainTypeName: mainTypeName,
      --                scriptClassName: WellKnownMemberNames.DefaultScriptClassName,
      --                usings: usings,
      --                optimizationLevel: optimize ? OptimizationLevel.Release : OptimizationLevel.Debug,
      --                checkOverflow: checkOverflow,
      --                allowUnsafe: allowUnsafe,
      --                deterministic: deterministic,
      --                concurrentBuild: concurrentBuild,
      --                cryptoKeyContainer: keyContainerSetting,
      --                cryptoKeyFile: keyFileSetting,
      --                delaySign: delaySignSetting,
      --                platform: platform,
      --                generalDiagnosticOption: generalDiagnosticOption,
      --                warningLevel: warningLevel,
      --                specificDiagnosticOptions: diagnosticOptions,
      --                reportSuppressedDiagnostics: reportSuppressedDiagnostics,
      --                publicSign: publicSign
      --            );

      --            if (debugPlus)
      --            {
      --                options = options.WithDebugPlusMode(debugPlus);
      --            }

      --            var emitOptions = new EmitOptions
      --            (
      --                metadataOnly: refOnly,
      --                includePrivateMembers: !refOnly && outputRefFilePath == null,
      --                debugInformationFormat: debugInformationFormat,
      --                pdbFilePath: null, // to be determined later
      --                outputNameOverride: null, // to be determined later
      --                baseAddress: baseAddress,
      --                highEntropyVirtualAddressSpace: highEntropyVA,
      --                fileAlignment: fileAlignment,
      --                subsystemVersion: subsystemVersion,
      --                runtimeMetadataVersion: runtimeMetadataVersion,
      --                instrumentationKinds: instrumentationKinds.ToImmutableAndFree(),
      --                // TODO: set from /checksumalgorithm (see https://github.com/dotnet/roslyn/issues/24735)
      --                pdbChecksumAlgorithm: HashAlgorithmName.SHA256
      --            );

      --            // add option incompatibility errors if any
      --            diagnostics.AddRange(options.Errors);
      --            diagnostics.AddRange(parseOptions.Errors);

      return System.create(MicrosoftCodeAnalysisCSharp.CSharpCommandLineArguments(), function (default) 
        default.IsScriptRunner = this.IsScriptCommandLineParser
        default.InteractiveMode = interactiveMode or this.IsScriptCommandLineParser and #sourceFiles == 0
        default.BaseDirectory = baseDirectory
        default.Utf8Output = utf8output
        default.OutputFileName = outputFileName
        default.OutputRefFilePath = outputRefFilePath
        default.PdbPath = pdbPath
        default.EmitPdb = emitPdb and not refOnly
        default.SourceLink = sourceLink
        default.RuleSetPath = ruleSetPath
        default.OutputDirectory = outputDirectory
        default.DocumentationPath = documentationPath
        default.ErrorLogPath = errorLogPath
        default.AppConfigPath = appConfigPath
        default.Encoding = codepage
        default.Win32ResourceFile = win32ResourceFile
        default.Win32Icon = win32IconFile
        default.Win32Manifest = win32ManifestFile
        default.NoWin32Manifest = noWin32Manifest
        default.DisplayLogo = displayLogo
        default.DisplayHelp = displayHelp
        default.DisplayVersion = displayVersion
        default.DisplayLangVersions = displayLangVersions
        default.TouchedFilesPath = touchedFilesPath
        default.PrintFullPaths = printFullPaths
        default.ShouldIncludeErrorEndLocation = errorEndLocation
        default.ReportAnalyzer = reportAnalyzer
      end)
    end
    CommonParse = function (this, args, baseDirectory, sdkDirectoryOpt, additionalReferenceDirectories) 
      return Parse1(this, args, baseDirectory, sdkDirectoryOpt, additionalReferenceDirectories)
    end
    GenerateErrorForNoFilesFoundInRecurse = function (this, path, errors) 
      System.throw(System.NotImplementedException())
    end
    return {
      __inherits__ = function (global) 
        return {
          global.Microsoft.CodeAnalysis.CommandLineParser
        }
      end, 
      getRegularFileExtension = getRegularFileExtension, 
      getScriptFileExtension = getScriptFileExtension, 
      Parse1 = Parse1, 
      CommonParse = CommonParse, 
      GenerateErrorForNoFilesFoundInRecurse = GenerateErrorForNoFilesFoundInRecurse, 
      __staticCtor__ = __staticCtor__, 
      __ctor__ = __ctor__
    }
  end)
end)
