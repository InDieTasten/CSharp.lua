-- Generated by CSharp.lua Compiler 1.1.0
-- Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.
local System = System
local Linq = System.Linq.Enumerable
local SystemIO = System.IO
local SystemText = System.Text
local MicrosoftCodeAnalysis
local RoslynUtilities
System.usingDeclare(function (global) 
  MicrosoftCodeAnalysis = Microsoft.CodeAnalysis
  RoslynUtilities = Roslyn.Utilities
end)
System.namespace("Microsoft.CodeAnalysis", function (namespace) 
  namespace.class("CommandLineParser", function (namespace) 
    local s_searchPatternTrimChars, getMessageProvider, Parse, ParseFileArgument, ToCommandLineSourceFile, ExpandFileNamePattern, EnumerateFiles, IsOption, 
    FlattenArgs, RemoveQuotesAndSlashes, TryParseOption, ProcessSlashes, Split, s_pathSeparators, s_wildcards, ParseSeparatedPaths, 
    ParseSeparatedStrings, __staticCtor__, __ctor__
    __staticCtor__ = function (this) 
      this.RemoveQuotesAndSlashes = RemoveQuotesAndSlashes
      this.TryParseOption = TryParseOption
      this.ProcessSlashes = ProcessSlashes
      this.ParseSeparatedPaths = ParseSeparatedPaths
      this.ParseSeparatedStrings = ParseSeparatedStrings
      s_searchPatternTrimChars = System.Array(System.Char)(9 --[['\t']], 10 --[['\n']], 11 --[['\v']], 12 --[['\f']], 13 --[['\r']], 32 --[[' ']], 133 --[['\u0085']], 160 --[['Â ']])
      s_pathSeparators = System.Array(System.Char)(59 --[[';']], 44 --[[',']])
      s_wildcards = System.Array(System.Char)(42 --[['*']], 63 --[['?']])
    end
    __ctor__ = function (this, messageProvider, isScriptCommandLineParser) 
      this._messageProvider = messageProvider
      this.IsScriptCommandLineParser = isScriptCommandLineParser
    end
    getMessageProvider = function (this) 
      return this._messageProvider
    end
    -- <summary>
    -- Parses a command line.
    -- </summary>
    -- <param name="args">A collection of strings representing the command line arguments.</param>
    -- <param name="baseDirectory">The base directory used for qualifying file locations.</param>
    -- <param name="sdkDirectory">The directory to search for mscorlib, or null if not available.</param>
    -- <param name="additionalReferenceDirectories">A string representing additional reference paths.</param>
    -- <returns>a <see cref="CommandLineArguments"/> object representing the parsed command line.</returns>
    Parse = function (this, args, baseDirectory, sdkDirectory, additionalReferenceDirectories) 
      return this:CommonParse(args, baseDirectory, sdkDirectory, additionalReferenceDirectories)
    end
    ParseFileArgument = function (this, arg, baseDirectory, errors) 
      return System.yieldIEnumerable(function (this, arg, baseDirectory, errors) 
        --Debug.Assert(IsScriptCommandLineParser || !arg.StartsWith("-", StringComparison.Ordinal) && !arg.StartsWith("@", StringComparison.Ordinal));

        -- We remove all doubles quotes from a file name. So that, for example:
        --   "Path With Spaces"\goo.cs
        -- becomes
        --   Path With Spaces\goo.cs

        local path = RemoveQuotesAndSlashes(arg)

        local wildcard = path:IndexOfAny(s_wildcards)
        if wildcard ~= - 1 then
          for _, file in System.each(ExpandFileNamePattern(this, path, baseDirectory, 0 --[[SearchOption.TopDirectoryOnly]], errors)) do
            System.yieldReturn(file)
          end
        else
          local resolvedPath = RoslynUtilities.FileUtilities.ResolveRelativePath(path, baseDirectory)
          if resolvedPath == nil then
            errors:Add(MicrosoftCodeAnalysis.Diagnostic.Create4(getMessageProvider(this), getMessageProvider(this):getFTL_InvalidInputFileName(), System.Array(System.Object)(path)))
          else
            System.yieldReturn(ToCommandLineSourceFile(this, resolvedPath))
          end
        end
      end, MicrosoftCodeAnalysis.CommandLineSourceFile, this, arg, baseDirectory, errors)
    end
    ToCommandLineSourceFile = function (this, resolvedPath) 
      local extension = RoslynUtilities.PathUtilities.GetExtension(resolvedPath)

      local isScriptFile
      if this.IsScriptCommandLineParser then
        isScriptFile = not System.String.Equals(extension, this:getRegularFileExtension(), 5 --[[StringComparison.OrdinalIgnoreCase]])
      else
        -- TODO: uncomment when fixing https://github.com/dotnet/roslyn/issues/5325
        --isScriptFile = string.Equals(extension, ScriptFileExtension, StringComparison.OrdinalIgnoreCase);
        isScriptFile = false
      end

      return MicrosoftCodeAnalysis.CommandLineSourceFile(resolvedPath, isScriptFile)
    end
    ExpandFileNamePattern = function (this, path, baseDirectory, searchOption, errors) 
      local directory = RoslynUtilities.PathUtilities.GetDirectoryName(path)
      local pattern = RoslynUtilities.PathUtilities.GetFileName(path, true)

      local default
      if (#directory == 0) then
        default = baseDirectory
      else
        default = RoslynUtilities.FileUtilities.ResolveRelativePath(directory, baseDirectory)
      end
      local resolvedDirectoryPath = default

      local enumerator = nil
      System.try(function () 
        local yielded = false

        -- NOTE: Directory.EnumerateFiles(...) surprisingly treats pattern "." the 
        --       same way as "*"; as we don't expect anything to be found by this 
        --       pattern, let's just not search in this case
        pattern = pattern:Trim(s_searchPatternTrimChars)
        local singleDotPattern = System.String.Equals(pattern, ".", 4 --[[StringComparison.Ordinal]])

        if not singleDotPattern then
          while true do
            local resolvedPath = nil
            System.try(function () 
              if enumerator == nil then
                enumerator = this:EnumerateFiles(resolvedDirectoryPath, pattern, searchOption):GetEnumerator()
              end

              if not enumerator:MoveNext() then
                break
              end

              resolvedPath = enumerator:getCurrent()
            end, function (default) 
              resolvedPath = nil
            end)

            if resolvedPath ~= nil then
              -- just in case EnumerateFiles returned a relative path
              resolvedPath = RoslynUtilities.FileUtilities.ResolveRelativePath(resolvedPath, baseDirectory)
            end

            if resolvedPath == nil then
              errors:Add(MicrosoftCodeAnalysis.Diagnostic.Create4(getMessageProvider(this), getMessageProvider(this):getFTL_InvalidInputFileName(), System.Array(System.Object)(path)))
              break
            end

            yielded = true
            System.yieldReturn(ToCommandLineSourceFile(this, resolvedPath))
          end
        end

        -- the pattern didn't match any files:
        if not yielded then
          if searchOption == 1 --[[SearchOption.AllDirectories]] then
            -- handling /recurse
            this:GenerateErrorForNoFilesFoundInRecurse(path, errors)
          else
            -- handling wildcard in file spec
            errors:Add(MicrosoftCodeAnalysis.Diagnostic.Create4(getMessageProvider(this), getMessageProvider(this):getERR_FileNotFound(), System.Array(System.Object)(path)))
          end
        end
      end, nil, function () 
        if enumerator ~= nil then
          enumerator:Dispose()
        end
      end)
    end
    -- <summary>
    -- Enumerates files in the specified directory and subdirectories whose name matches the given pattern.
    -- </summary>
    -- <param name="directory">Full path of the directory to enumerate.</param>
    -- <param name="fileNamePattern">File name pattern. May contain wildcards '*' (matches zero or more characters) and '?' (matches any character).</param>
    -- <param name="searchOption">Specifies whether to search the specified <paramref name="directory"/> only, or all its subdirectories as well.</param>
    -- <returns>Sequence of file paths.</returns>
    EnumerateFiles = function (this, directory, fileNamePattern, searchOption) 
      --Debug.Assert(PathUtilities.IsAbsolute(directory));
      return SystemIO.Directory.EnumerateFiles(directory, fileNamePattern, searchOption)
    end
    IsOption = function (arg) 
      return not System.String.IsNullOrEmpty(arg) and (arg:get(0) == 47 --[['/']] or arg:get(0) == 45 --[['-']])
    end
    FlattenArgs = function (this, rawArguments, diagnostics, processedArgs, scriptArgsOpt, baseDirectory, responsePaths) 
      local parsingScriptArgs = false
      local sourceFileSeen = false
      local optionsEnded = false

      local args = System.Stack(System.String)(Linq.Reverse(rawArguments))
      while #args > 0 do
        local continue
        repeat
          -- EDMAURER trim off whitespace. Otherwise behavioral differences arise
          -- when the strings which represent args are constructed by cmd or users.
          -- cmd won't produce args with whitespace at the end.
          local arg = args:Pop():TrimEnd()

          if parsingScriptArgs then
            scriptArgsOpt:Add(arg)
            continue = true
            break
          end

          if scriptArgsOpt ~= nil then
            -- The order of the following two checks matters.
            --
            -- Command line:               Script:    Script args:
            --   csi -- script.csx a b c   script.csx      ["a", "b", "c"]
            --   csi script.csx -- a b c   script.csx      ["--", "a", "b", "c"]
            --   csi -- @script.csx a b c  @script.csx     ["a", "b", "c"]
            --
            if sourceFileSeen then
              -- csi/vbi: at most one script can be specified on command line, anything else is a script arg:
              parsingScriptArgs = true
              scriptArgsOpt:Add(arg)
              continue = true
              break
            end

            if not optionsEnded and arg == "--" then
              -- csi/vbi: no argument past "--" should be treated as an option/response file
              optionsEnded = true
              processedArgs:Add(arg)
              continue = true
              break
            end
          end

          if not optionsEnded and arg:StartsWith("@", 4 --[[StringComparison.Ordinal]]) then
            -- response file:
            local path = RemoveQuotesAndSlashes(arg:Substring(1)):TrimEnd(nil)
            System.throw(System.NotImplementedException())
            --  string resolvedPath = FileUtilities.ResolveRelativePath(path, baseDirectory);
            --if (resolvedPath != null)
            --{
            --    foreach (string newArg in ParseResponseFile(resolvedPath, diagnostics).Reverse())
            --    {
            --        // Ignores /noconfig option specified in a response file
            --        if (!string.Equals(newArg, "/noconfig", StringComparison.OrdinalIgnoreCase) && !string.Equals(newArg, "-noconfig", StringComparison.OrdinalIgnoreCase))
            --        {
            --            args.Push(newArg);
            --        }
            --        else
            --        {
            --            diagnostics.Add(Diagnostic.Create(_messageProvider, _messageProvider.WRN_NoConfigNotOnCommandLine));
            --        }
            --    }

            --    if (responsePaths != null)
            --    {
            --        responsePaths.Add(FileUtilities.NormalizeAbsolutePath(PathUtilities.GetDirectoryName(resolvedPath)));
            --    }
            --}
            --else
            --{
            --    diagnostics.Add(Diagnostic.Create(_messageProvider, _messageProvider.FTL_InvalidInputFileName, path));
            --}
          else
            processedArgs:Add(arg)
            sourceFileSeen = sourceFileSeen or (optionsEnded or not IsOption(arg))
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end
    end
    -- <summary>
    -- Remove the extraneous quotes and slashes from the argument.  This function is designed to have
    -- compat behavior with the native compiler.
    -- </summary>
    -- <remarks>
    -- Mimics the function RemoveQuotes from the native C# compiler.  The native VB equivalent of this
    -- function is called RemoveQuotesAndSlashes.  It has virtually the same behavior except for a few
    -- quirks in error cases.
    -- </remarks>
    RemoveQuotesAndSlashes = function (arg) 
      if arg == nil then
        return arg
      end

      local builder = SystemText.StringBuilder()
      -- [Lua] Originally comes from PooledStringBuilder.Instance.Builder
      local i = 0
      while i < #arg do
        local cur = arg:get(i)
        repeat
          local default = cur
          if default == 92 --[['\\']] then
            i = ProcessSlashes(builder, arg, i)
            break
          elseif default == 34 --[['"']] then
            i = i + 1
            break
          else
            builder:AppendChar(cur)
            i = i + 1
            break
          end
        until 1
      end

      return builder:ToString()
    end
    TryParseOption = function (arg, name, value) 
      if not IsOption(arg) then
        name = nil
        value = nil
        return false, name, value
      end

      local colon = arg:IndexOf(58 --[[':']])

      -- temporary heuristic to detect Unix-style rooted paths
      -- pattern /goo/*  or  //* will not be treated as a compiler option
      --
      -- TODO: consider introducing "/s:path" to disambiguate paths starting with /
      if #arg > 1 and arg:get(0) ~= 45 --[['-']] then
        local separator = arg:IndexOf(47 --[['/']], 1)
        if separator > 0 and (colon < 0 or separator < colon) then
          --   "/goo/
          --   "//
          name = nil
          value = nil
          return false, name, value
        end
      end

      if colon >= 0 then
        name = arg:Substring(1, colon - 1)
        value = arg:Substring(colon + 1)
      else
        name = arg:Substring(1)
        value = nil
      end

      name = name:ToLowerInvariant()
      return true, name, value
    end
    -- <summary>
    -- Mimic behavior of the native function by the same name.
    -- </summary>
    ProcessSlashes = function (builder, arg, i) 
      --Debug.Assert(arg != null);
      --Debug.Assert(i < arg.Length);

      local slashCount = 0
      while i < #arg and arg:get(i) == 92 --[['\\']] do
        slashCount = slashCount + 1
        i = i + 1
      end

      if i < #arg and arg:get(i) == 34 --[['"']] then
        -- Before a quote slashes are interpretted as escape sequences for other slashes so
        -- output one for every two.
        while slashCount >= 2 do
          builder:AppendChar(92 --[['\\']])
          slashCount = slashCount - 2
        end

        --Debug.Assert(slashCount >= 0);

        -- If there is an odd number of slashes then the quote is escaped and hence a part
        -- of the output.  Otherwise it is a normal quote and can be ignored. 
        if slashCount == 1 then
          -- The quote is escaped so eat it.
          builder:AppendChar(34 --[['"']])
        end

        i = i + 1
      else
        -- Slashes that aren't followed by quotes are simply slashes.
        while slashCount > 0 do
          builder:AppendChar(92 --[['\\']])
          slashCount = slashCount - 1
        end
      end
      return i
    end
    -- <summary>
    -- Split a string, based on whether "splitHere" returned true on each character.
    -- </summary>
    Split = function (str, splitHere) 
      return System.yieldIEnumerable(function (str, splitHere) 
        if str == nil then
          return
        end

        local nextPiece = 0

        do
          local c = 0
          while c < #str do
            if splitHere(str:get(c)) then
              System.yieldReturn(str:Substring(nextPiece, c - nextPiece))
              nextPiece = c + 1
            end
            c = c + 1
          end
        end

        System.yieldReturn(str:Substring(nextPiece))
      end, System.String, str, splitHere)
    end
    ParseSeparatedPaths = function (str) 
      return Linq.Select(ParseSeparatedStrings(str, s_pathSeparators, 1 --[[StringSplitOptions.RemoveEmptyEntries]]), RemoveQuotesAndSlashes, System.String)
    end
    -- <summary>
    -- Split a string by a set of separators, taking quotes into account.
    -- </summary>
    ParseSeparatedStrings = function (str, separators, options) 
      local inQuotes = false

      local result = Split(str, (function (c) 
        if c == 34 --[['"']] then
          inQuotes = not inQuotes
        end

        return not inQuotes and Linq.Contains(separators, c)
      end))

      local default
      if (options == 1 --[[StringSplitOptions.RemoveEmptyEntries]]) then
        default = Linq.Where(result, function (s) 
          return #s > 0
        end)
      else
        default = result
      end
      return default
    end
    return {
      IsScriptCommandLineParser = false, 
      getMessageProvider = getMessageProvider, 
      Parse = Parse, 
      ParseFileArgument = ParseFileArgument, 
      EnumerateFiles = EnumerateFiles, 
      FlattenArgs = FlattenArgs, 
      __staticCtor__ = __staticCtor__, 
      __ctor__ = __ctor__
    }
  end)
end)
