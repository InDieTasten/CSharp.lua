-- Generated by CSharp.lua Compiler 1.1.0
-- Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.
local System = System
local RoslynUtilities
System.usingDeclare(function (global) 
  RoslynUtilities = Roslyn.Utilities
end)
System.namespace("Roslyn.Utilities", function (namespace) 
  namespace.class("FileUtilities", function (namespace) 
    local ResolveRelativePath, ResolveRelativePath1, ResolveRelativePath2, GetBaseDirectory
    ResolveRelativePath = function (path, baseDirectory) 
      return ResolveRelativePath1(path, nil, baseDirectory)
    end
    ResolveRelativePath1 = function (path, basePath, baseDirectory) 
      -- Debug.Assert(baseDirectory == null || PathUtilities.IsAbsolute(baseDirectory));
      return ResolveRelativePath2(RoslynUtilities.PathUtilities.GetPathKind(path), path, basePath, baseDirectory)
    end
    ResolveRelativePath2 = function (kind, path, basePath, baseDirectory) 
      repeat
        local default = kind
        if default == 0 --[[PathKind.Empty]] then
          return nil
        elseif default == 1 --[[PathKind.Relative]] then
          baseDirectory = GetBaseDirectory(basePath, baseDirectory)
          if baseDirectory == nil then
            return nil
          end
          return RoslynUtilities.PathUtilities.CombinePathsUnchecked(baseDirectory, path)
        elseif default == 2 --[[PathKind.RelativeToCurrentDirectory]] then
          baseDirectory = GetBaseDirectory(basePath, baseDirectory)
          if baseDirectory == nil then
            return nil
          end
          if #path == 1 then
            -- "."
            return baseDirectory
          else
            -- ".\path"
            return RoslynUtilities.PathUtilities.CombinePathsUnchecked(baseDirectory, path)
          end
        elseif default == 3 --[[PathKind.RelativeToCurrentParent]] then
          baseDirectory = GetBaseDirectory(basePath, baseDirectory)
          if baseDirectory == nil then
            return nil
          end
          return RoslynUtilities.PathUtilities.CombinePathsUnchecked(baseDirectory, path)
        elseif default == 4 --[[PathKind.RelativeToCurrentRoot]] then
          local baseRoot
          if basePath ~= nil then
            baseRoot = RoslynUtilities.PathUtilities.GetPathRoot1(basePath)
          elseif baseDirectory ~= nil then
            baseRoot = RoslynUtilities.PathUtilities.GetPathRoot1(baseDirectory)
          else
            return nil
          end
          if System.String.IsNullOrEmpty(baseRoot) then
            return nil
          end
          return RoslynUtilities.PathUtilities.CombinePathsUnchecked(baseRoot, path:Substring(1))
        elseif default == 5 --[[PathKind.RelativeToDriveDirectory]] then
          return nil
        elseif default == 6 --[[PathKind.Absolute]] then
          return path
        else
          System.throw(RoslynUtilities.ExceptionUtilities.UnexpectedValue(kind))
        end
      until 1
    end
    GetBaseDirectory = function (basePath, baseDirectory) 
      -- relative base paths are relative to the base directory:
      local resolvedBasePath = ResolveRelativePath(basePath, baseDirectory)
      if resolvedBasePath == nil then
        return baseDirectory
      end

      -- Note: Path.GetDirectoryName doesn't normalize the path and so it doesn't depend on the process state.
      -- Debug.Assert(PathUtilities.IsAbsolute(resolvedBasePath));
      local default, extern = System.try(function () 
        return true, RoslynUtilities.PathUtilities.GetDirectoryName(resolvedBasePath)
        -- [Lua] This was using System.IO.Path version before :S
      end, function (default) 
        return true, nil
      end)
      if default then
        return extern
      end
    end
    return {
      ResolveRelativePath = ResolveRelativePath, 
      ResolveRelativePath1 = ResolveRelativePath1
    }
  end)
end)
